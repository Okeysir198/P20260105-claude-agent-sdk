"""
Domain Logic Calculator for {agent_name}

Implements business calculations based on category, tier, and input values.
Separated from tools to allow reuse and easier testing.

This follows the debt_collection reference where discount calculations,
installment plans, and validation logic are centralized here.

Customize the calculation functions for your specific domain.
"""

from datetime import date, timedelta
from typing import Dict, Any, Optional, Tuple, List
from .config import CATEGORIES, TIER_RULES, get_tier_for_value, get_category_config


def calculate_result(
    category: str,
    base_value: float,
    quantity: int = 1,
    apply_discount: bool = False,
) -> Optional[Dict[str, Any]]:
    """
    Calculate result based on category and input values.

    This is a generic calculation pattern - customize for your domain.
    Examples: pricing, scheduling, resource allocation, etc.

    Args:
        category: Category type (e.g., 'standard', 'premium')
        base_value: Base value for calculation
        quantity: Number of items/units
        apply_discount: Whether to apply category discount

    Returns:
        Dictionary containing:
        - original_value: Input value before calculations
        - calculated_value: Final calculated value
        - tier: Applied tier name
        - category: Applied category
        - breakdown: Detailed calculation breakdown
        Returns None if category not found

    Example:
        >>> result = calculate_result("premium", 100.0, quantity=2)
        >>> result["calculated_value"]
        200.0
    """
    # Validate category
    category_config = get_category_config(category)
    if not category_config:
        return None

    # Get applicable tier
    tier_name, tier_config = get_tier_for_value(base_value)

    # Calculate base total
    subtotal = base_value * quantity

    # Apply category-specific adjustments
    discount_pct = 0.0
    if apply_discount and category_config.get("options_enabled"):
        # Example: Premium gets 10% discount, Enterprise gets 20%
        discount_pct = {
            "standard": 0.0,
            "premium": 10.0,
            "enterprise": 20.0,
        }.get(category, 0.0)

    discount_amount = subtotal * (discount_pct / 100)
    final_value = subtotal - discount_amount

    return {
        "original_value": base_value,
        "quantity": quantity,
        "subtotal": round(subtotal, 2),
        "discount_percentage": discount_pct,
        "discount_amount": round(discount_amount, 2),
        "calculated_value": round(final_value, 2),
        "tier": tier_name,
        "category": category,
        "category_name": category_config.get("name", category),
        "breakdown": {
            "base": round(base_value, 2),
            "quantity": quantity,
            "subtotal": round(subtotal, 2),
            "discount": round(discount_amount, 2),
            "final": round(final_value, 2),
        },
    }


def validate_input(
    category: str,
    value: float,
    quantity: int = 1,
) -> Dict[str, Any]:
    """
    Validate input against business rules.

    Args:
        category: Category type
        value: Value to validate
        quantity: Quantity to validate

    Returns:
        Dictionary containing:
        - valid: Boolean indicating if input is valid
        - reason: Explanation if invalid
        - constraints: Applied constraints

    Example:
        >>> result = validate_input("standard", 100.0, quantity=10)
        >>> result["valid"]
        False
        >>> result["reason"]
        'Exceeds maximum of 5 items for standard'
    """
    # Validate category exists
    category_config = get_category_config(category)
    if not category_config:
        return {
            "valid": False,
            "reason": f"Unknown category: {category}",
            "constraints": {},
        }

    # Check quantity limits
    max_items = category_config.get("max_items", -1)
    if max_items > 0 and quantity > max_items:
        return {
            "valid": False,
            "reason": f"Exceeds maximum of {max_items} items for {category}",
            "constraints": {"max_items": max_items},
        }

    # Check value constraints
    if value <= 0:
        return {
            "valid": False,
            "reason": "Value must be positive",
            "constraints": {"min_value": 0.01},
        }

    # Get tier constraints
    tier_name, tier_config = get_tier_for_value(value)
    min_duration = tier_config.get("min_duration", 1)

    return {
        "valid": True,
        "reason": None,
        "constraints": {
            "category": category,
            "tier": tier_name,
            "max_items": max_items,
            "min_duration": min_duration,
        },
    }


def get_options(
    category: str,
    value: float,
) -> List[Dict[str, Any]]:
    """
    Get available options based on category and value.

    Generates a list of possible configurations/choices
    the user can select from.

    Args:
        category: Category type
        value: Base value for options

    Returns:
        List of option dictionaries

    Example:
        >>> options = get_options("premium", 300.0)
        >>> len(options)
        3
    """
    category_config = get_category_config(category)
    if not category_config or not category_config.get("options_enabled"):
        return []

    tier_name, tier_config = get_tier_for_value(value)
    min_duration = tier_config.get("min_duration", 1)

    options = []

    # Option 1: Immediate/Quick
    options.append({
        "id": "immediate",
        "name": "Immediate",
        "description": "Process immediately",
        "duration": 0,
        "value": value,
        "recommended": value < 100,
    })

    # Option 2: Standard duration
    options.append({
        "id": "standard",
        "name": "Standard",
        "description": f"Process over {min_duration} periods",
        "duration": min_duration,
        "value_per_period": round(value / min_duration, 2),
        "recommended": 100 <= value < 500,
    })

    # Option 3: Extended duration
    extended_duration = min_duration * 2
    options.append({
        "id": "extended",
        "name": "Extended",
        "description": f"Process over {extended_duration} periods",
        "duration": extended_duration,
        "value_per_period": round(value / extended_duration, 2),
        "recommended": value >= 500,
    })

    return options


def calculate_schedule(
    total_value: float,
    periods: int,
    start_date: Optional[date] = None,
) -> Dict[str, Any]:
    """
    Calculate a schedule/plan for distributing value over periods.

    Args:
        total_value: Total value to distribute
        periods: Number of periods
        start_date: Start date (defaults to today)

    Returns:
        Dictionary containing schedule details

    Example:
        >>> schedule = calculate_schedule(300.0, 3)
        >>> len(schedule["periods"])
        3
    """
    if start_date is None:
        start_date = date.today()

    value_per_period = total_value / periods

    period_list = []
    current_date = start_date

    for i in range(periods):
        period_list.append({
            "period": i + 1,
            "date": current_date.isoformat(),
            "value": round(value_per_period, 2),
            "cumulative": round(value_per_period * (i + 1), 2),
        })
        # Move to next period (assume monthly)
        if current_date.month == 12:
            current_date = date(current_date.year + 1, 1, current_date.day)
        else:
            try:
                current_date = date(current_date.year, current_date.month + 1, current_date.day)
            except ValueError:
                # Handle months with fewer days
                current_date = date(current_date.year, current_date.month + 2, 1) - timedelta(days=1)

    return {
        "total_value": round(total_value, 2),
        "periods": periods,
        "value_per_period": round(value_per_period, 2),
        "start_date": start_date.isoformat(),
        "end_date": period_list[-1]["date"] if period_list else start_date.isoformat(),
        "schedule": period_list,
    }
