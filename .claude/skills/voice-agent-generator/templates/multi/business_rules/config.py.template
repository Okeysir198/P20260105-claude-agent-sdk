"""
Configuration and Constants for {agent_name} Business Rules

Defines domain-specific categories, types, default values, and business
constraints used throughout the voice agent workflow.

This pattern follows the debt_collection reference implementation where
script types, authorities, fees, and rules are centralized here rather
than scattered across tool implementations.

Customize the constants below for your specific domain.
"""

from datetime import date, time, timedelta
from typing import Dict, Any, Optional


# ============================================================
# CATEGORY CONFIGURATIONS
# ============================================================
# Define domain-specific categories/types that drive agent behavior.
# Example: script types, service tiers, product categories, etc.

CATEGORIES: Dict[str, Dict[str, Any]] = {
    # Example category structure - customize for your domain
    "standard": {
        "name": "Standard",
        "description": "Standard service tier",
        "priority": 1,
        "options_enabled": True,
        "max_items": 5,
        # Add domain-specific fields:
        # "discount_percentage": 0,
        # "escalation_level": "none",
    },
    "premium": {
        "name": "Premium",
        "description": "Premium service tier with additional benefits",
        "priority": 2,
        "options_enabled": True,
        "max_items": 10,
    },
    "enterprise": {
        "name": "Enterprise",
        "description": "Enterprise service tier with full access",
        "priority": 3,
        "options_enabled": True,
        "max_items": -1,  # Unlimited
    },
}


# ============================================================
# DEFAULT VALUES
# ============================================================
# Central place for default values used across the agent.

DEFAULT_VALUES: Dict[str, Any] = {
    "agent_name": "{default_agent_name}",
    "timeout_seconds": 30,
    "max_retries": 3,
    "confirmation_required": True,
    # Add domain-specific defaults:
    # "currency": "USD",
    # "default_quantity": 1,
}


# ============================================================
# BUSINESS HOURS
# ============================================================
# Define when the service is available.

BUSINESS_HOURS = {
    "start": time(8, 0),   # 08:00
    "end": time(18, 0),    # 18:00
    "days": [0, 1, 2, 3, 4],  # Monday=0 to Friday=4
    "timezone": "UTC",
    "buffer_minutes": 15,  # No actions within N minutes of closing
}


# ============================================================
# TIER/LEVEL RULES
# ============================================================
# Define rules that vary by tier, amount, or other criteria.

TIER_RULES: Dict[str, Any] = {
    "tier1": {
        "max_value": 100.0,
        "min_duration": 1,
        "description": "Small requests - quick processing",
    },
    "tier2": {
        "min_value": 100.01,
        "max_value": 500.0,
        "min_duration": 3,
        "description": "Medium requests - standard processing",
    },
    "tier3": {
        "min_value": 500.01,
        "min_duration": 5,
        "description": "Large requests - extended processing",
    },
}


# ============================================================
# LOOKUP FUNCTIONS
# ============================================================

def get_category_config(category_key: str) -> Optional[Dict[str, Any]]:
    """
    Get configuration for a specific category.

    Args:
        category_key: The category identifier (e.g., 'standard', 'premium')

    Returns:
        Configuration dict or None if category not found

    Example:
        >>> config = get_category_config("premium")
        >>> config["max_items"]
        10
    """
    return CATEGORIES.get(category_key)


def get_default_value(key: str, fallback: Any = None) -> Any:
    """
    Get a default value by key.

    Args:
        key: The default value key
        fallback: Value to return if key not found

    Returns:
        The default value or fallback

    Example:
        >>> get_default_value("timeout_seconds")
        30
    """
    return DEFAULT_VALUES.get(key, fallback)


def get_tier_for_value(value: float) -> tuple[str, Dict[str, Any]]:
    """
    Determine which tier applies for a given value.

    Args:
        value: The value to evaluate

    Returns:
        Tuple of (tier_name, tier_config)

    Example:
        >>> tier_name, config = get_tier_for_value(250.0)
        >>> tier_name
        'tier2'
    """
    for tier_name, tier_config in TIER_RULES.items():
        min_val = tier_config.get("min_value", 0)
        max_val = tier_config.get("max_value", float("inf"))

        if min_val <= value <= max_val:
            return (tier_name, tier_config)

    # Default to highest tier if no match
    return ("tier3", TIER_RULES["tier3"])


def is_within_hours(check_time: Optional[time] = None) -> bool:
    """
    Check if current time is within business hours.

    Args:
        check_time: Time to check (defaults to current time)

    Returns:
        True if within business hours

    Example:
        >>> is_within_hours(time(10, 0))
        True
    """
    from datetime import datetime

    if check_time is None:
        check_time = datetime.now().time()

    current_day = datetime.now().weekday()

    # Check if it's a business day
    if current_day not in BUSINESS_HOURS["days"]:
        return False

    # Check if within hours
    start = BUSINESS_HOURS["start"]
    end = BUSINESS_HOURS["end"]

    # Account for buffer before closing
    buffer = timedelta(minutes=BUSINESS_HOURS.get("buffer_minutes", 0))
    end_with_buffer = (
        datetime.combine(date.today(), end) - buffer
    ).time()

    return start <= check_time <= end_with_buffer


def get_deadline(days_from_now: int = 7) -> date:
    """
    Calculate a deadline date from today.

    Args:
        days_from_now: Number of days until deadline

    Returns:
        Deadline date

    Example:
        >>> deadline = get_deadline(7)
        >>> (deadline - date.today()).days
        7
    """
    return date.today() + timedelta(days=days_from_now)
