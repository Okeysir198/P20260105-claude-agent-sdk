"""
Fuzzy Matching Utilities for Voice Input Verification

This module implements fuzzy matching for verifying user-provided information
during voice agent conversations. Handles common voice transcription variations
and spoken digit conversions.

Key Features:
- Handles voice input variations (spoken digits, common misheard words)
- Normalizes values across different field types (phone numbers, dates, IDs)
- Provides configurable match thresholds per field type
- Supports progressive verification workflows

Usage:
    from utils.fuzzy_match import fuzzy_match, verify_field

    # Basic matching
    result = fuzzy_match("oh eight two one", "0821", "phone")
    if result["matched"]:
        print("Phone verified!")

    # Field verification against profile
    profile = {"phone": "0821234567", "email": "user@example.com"}
    result = verify_field("phone", "oh eight two one two three four", profile)
"""

import re
import difflib
from datetime import datetime
from typing import Any, Dict, List, Optional, Tuple


# ============================================================
# SPOKEN DIGIT CONVERSION
# ============================================================

# Mapping of spoken words to digits
DIGIT_WORDS: Dict[str, str] = {
    # Zero variations
    "oh": "0",
    "o": "0",
    "zero": "0",
    "nil": "0",

    # Single digits
    "one": "1",
    "two": "2",
    "to": "2",
    "too": "2",
    "three": "3",
    "four": "4",
    "for": "4",
    "five": "5",
    "six": "6",
    "seven": "7",
    "eight": "8",
    "ate": "8",
    "nine": "9",

    # Teens
    "ten": "10",
    "eleven": "11",
    "twelve": "12",
    "thirteen": "13",
    "fourteen": "14",
    "fifteen": "15",
    "sixteen": "16",
    "seventeen": "17",
    "eighteen": "18",
    "nineteen": "19",

    # Tens
    "twenty": "20",
    "thirty": "30",
    "forty": "40",
    "fifty": "50",
    "sixty": "60",
    "seventy": "70",
    "eighty": "80",
    "ninety": "90",
}


def convert_spoken_digits(text: str) -> str:
    """
    Convert spoken words to digits for voice input processing.

    Handles common voice input variations:
    - "oh", "o", "zero" -> "0"
    - "one" through "nine" -> "1" through "9"
    - "double three" -> "33"
    - "twenty-five" -> "25"

    Args:
        text: Input text potentially containing spoken digits

    Returns:
        Text with spoken digits converted to numeric digits

    Examples:
        >>> convert_spoken_digits("oh eight one two three")
        "08123"
        >>> convert_spoken_digits("double three four")
        "334"
    """
    if not text:
        return ""

    text = text.lower().strip()

    # Handle "double" followed by digit word
    double_pattern = r'\bdouble\s+(\w+)'
    matches = re.finditer(double_pattern, text)
    for match in reversed(list(matches)):
        word = match.group(1)
        if word in DIGIT_WORDS:
            digit = DIGIT_WORDS[word]
            replacement = digit + digit
            text = text[:match.start()] + replacement + text[match.end():]

    # Handle compound numbers like "twenty-five" -> "25"
    tens_words = ["twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"]
    ones_words = ["one", "two", "three", "four", "five", "six", "seven", "eight", "nine"]

    for tens_word in tens_words:
        tens_value = DIGIT_WORDS[tens_word]
        for ones_word in ones_words:
            ones_value = DIGIT_WORDS[ones_word]
            compound_pattern = rf'\b{tens_word}[\s-]{ones_word}\b'
            compound_number = str(int(tens_value) + int(ones_value))
            text = re.sub(compound_pattern, compound_number, text)

    # Replace individual digit words
    words = text.split()
    converted = []

    for word in words:
        word_clean = word.strip(".,;:!?-")
        if word_clean in DIGIT_WORDS:
            converted.append(DIGIT_WORDS[word_clean])
        else:
            converted.append(word)

    result = " ".join(converted)

    # Remove spaces between consecutive digits
    result = re.sub(r'(\d)\s+(?=\d)', r'\1', result)

    return result


# ============================================================
# FIELD CONFIGURATION
# ============================================================

# Match thresholds per field type (0.0 to 1.0)
# Higher = stricter matching required
MATCH_THRESHOLDS: Dict[str, float] = {
    "id_number": 0.95,
    "phone": 0.90,
    "email": 0.85,
    "date": 0.80,
    "name": 0.80,
    "address": 0.70,
    "reference": 0.90,
    "default": 0.80,
}


# ============================================================
# VALUE NORMALIZATION
# ============================================================

def normalize_value(value: str, field_type: str) -> str:
    """
    Normalize values for consistent comparison.

    Applies field-specific normalization rules:
    - Phone: Remove country code, spaces, dashes
    - Email: Lowercase, handle "at" and "dot"
    - Date: Parse to YYYY-MM-DD format
    - Default: Lowercase, remove special characters

    Args:
        value: Raw value to normalize
        field_type: Type of field (determines normalization rules)

    Returns:
        Normalized value ready for comparison

    Examples:
        >>> normalize_value("+1 555 123 4567", "phone")
        "5551234567"
        >>> normalize_value("user at example dot com", "email")
        "user@example.com"
    """
    if not value:
        return ""

    # Convert spoken digits first
    value = convert_spoken_digits(str(value))
    value = value.strip().lower()

    if field_type in ["phone", "mobile", "contact"]:
        # Remove all non-digit characters
        digits = re.sub(r'\D', '', value)

        # Remove common country codes
        for prefix in ["1", "44", "27", "61", "91"]:
            if digits.startswith(prefix) and len(digits) > 10:
                digits = digits[len(prefix):]
                break

        # Remove leading 0 (local format)
        if digits.startswith("0") and len(digits) > 9:
            digits = digits[1:]

        return digits

    elif field_type == "email":
        value = value.replace(" ", "")
        value = re.sub(r'\s*at\s*', '@', value)
        value = re.sub(r'\s*dot\s*', '.', value)
        return value

    elif field_type == "date":
        # Remove spoken words
        value = re.sub(r'\b(born on|date is|dob)\b', '', value).strip()

        # Try multiple date formats
        formats = [
            "%Y-%m-%d", "%Y/%m/%d",
            "%d-%m-%Y", "%d/%m/%Y",
            "%m-%d-%Y", "%m/%d/%Y",
            "%B %d, %Y", "%d %B %Y",
        ]

        for fmt in formats:
            try:
                parsed = datetime.strptime(value, fmt)
                return parsed.strftime("%Y-%m-%d")
            except ValueError:
                continue

        # Fallback: extract digits only
        return re.sub(r'\D', '', value)

    elif field_type in ["id_number", "reference", "code"]:
        # Keep only alphanumeric
        return re.sub(r'[^a-z0-9]', '', value)

    elif field_type == "address":
        # Keep alphanumeric and spaces
        value = re.sub(r'[^\w\s]', '', value)
        value = re.sub(r'\s+', ' ', value)
        return value.strip()

    else:
        # Default: keep alphanumeric and spaces
        value = re.sub(r'[^\w\s]', '', value)
        value = re.sub(r'\s+', ' ', value)
        return value.strip()


# ============================================================
# FUZZY MATCHING
# ============================================================

def fuzzy_match(
    provided_value: str,
    expected_value: str,
    field_type: str = "default",
) -> Dict[str, Any]:
    """
    Perform fuzzy matching between provided and expected values.

    Uses difflib.SequenceMatcher for similarity comparison with
    field-specific thresholds.

    Args:
        provided_value: Value provided by user (voice input)
        expected_value: Expected value from profile/database
        field_type: Type of field being matched

    Returns:
        Dictionary containing:
        - matched (bool): Whether values match within threshold
        - similarity (float): Similarity ratio (0.0 to 1.0)
        - normalized_provided (str): Normalized provided value
        - normalized_expected (str): Normalized expected value

    Examples:
        >>> fuzzy_match("oh eight two one", "0821", "phone")
        {"matched": True, "similarity": 1.0, ...}
    """
    normalized_provided = normalize_value(provided_value, field_type)
    normalized_expected = normalize_value(expected_value, field_type)

    if not normalized_provided or not normalized_expected:
        return {
            "matched": False,
            "similarity": 0.0,
            "normalized_provided": normalized_provided,
            "normalized_expected": normalized_expected,
        }

    # Calculate similarity
    similarity = difflib.SequenceMatcher(
        None,
        normalized_provided,
        normalized_expected,
    ).ratio()

    # Get threshold
    threshold = MATCH_THRESHOLDS.get(field_type, MATCH_THRESHOLDS["default"])
    matched = similarity >= threshold

    return {
        "matched": matched,
        "similarity": round(similarity, 3),
        "normalized_provided": normalized_provided,
        "normalized_expected": normalized_expected,
    }


def verify_field(
    field_name: str,
    provided_value: str,
    profile: Dict[str, Any],
    field_type: Optional[str] = None,
) -> Dict[str, Any]:
    """
    Verify a single field against a profile dictionary.

    Args:
        field_name: Name of field to verify (key in profile)
        provided_value: Value provided by user
        profile: Profile dictionary containing expected values
        field_type: Override field type for normalization

    Returns:
        Dictionary containing:
        - status: "MATCHED", "NOT_MATCHED", "CLOSE_MATCH", or "NOT_AVAILABLE"
        - similarity: Similarity ratio
        - field: Field name
        - message: Human-readable result

    Example:
        >>> profile = {"phone": "0821234567"}
        >>> verify_field("phone", "oh eight two one two three four", profile)
        {"status": "MATCHED", "similarity": 0.95, ...}
    """
    # Check if field exists
    if field_name not in profile:
        return {
            "status": "NOT_AVAILABLE",
            "similarity": 0.0,
            "field": field_name,
            "message": f"Field '{field_name}' not in profile",
        }

    expected = profile.get(field_name)
    if not expected:
        return {
            "status": "NOT_AVAILABLE",
            "similarity": 0.0,
            "field": field_name,
            "message": f"No value for '{field_name}' in profile",
        }

    # Use field_name as type if not overridden
    ftype = field_type or field_name

    # Perform match
    result = fuzzy_match(provided_value, expected, ftype)
    threshold = MATCH_THRESHOLDS.get(ftype, MATCH_THRESHOLDS["default"])

    if result["matched"]:
        return {
            "status": "MATCHED",
            "similarity": result["similarity"],
            "field": field_name,
            "message": f"Successfully verified {field_name}",
        }
    elif result["similarity"] >= (threshold - 0.15):
        # Close match (within 15% of threshold)
        return {
            "status": "CLOSE_MATCH",
            "similarity": result["similarity"],
            "field": field_name,
            "message": f"Partial match ({int(result['similarity'] * 100)}%) - please verify {field_name} again",
        }
    else:
        return {
            "status": "NOT_MATCHED",
            "similarity": result["similarity"],
            "field": field_name,
            "message": f"Does not match records for {field_name}",
        }


def is_verified(
    verified_fields: List[str],
    results: Dict[str, Dict[str, Any]],
    required_count: int = 2,
    priority_fields: Optional[List[str]] = None,
) -> Tuple[bool, str]:
    """
    Check if identity is sufficiently verified.

    Rules:
    - If any priority field is MATCHED -> Verified
    - Otherwise need required_count other fields MATCHED -> Verified
    - Else -> Not verified

    Args:
        verified_fields: List of field names that were checked
        results: Dict mapping field names to verification results
        required_count: Number of fields needed if no priority match
        priority_fields: Fields that alone can verify identity

    Returns:
        Tuple of (is_verified, reason)

    Example:
        >>> results = {"phone": {"status": "MATCHED"}}
        >>> is_verified(["phone"], results, priority_fields=["phone", "id"])
        (True, "Verified via phone")
    """
    priority_fields = priority_fields or []

    # Check priority fields first
    for field in priority_fields:
        if field in verified_fields:
            result = results.get(field, {})
            if result.get("status") == "MATCHED":
                return (True, f"Verified via {field}")

    # Count matched non-priority fields
    matched_count = 0
    matched_fields = []

    for field in verified_fields:
        if field not in priority_fields:
            result = results.get(field, {})
            if result.get("status") == "MATCHED":
                matched_count += 1
                matched_fields.append(field)

    if matched_count >= required_count:
        fields_str = ", ".join(matched_fields[:required_count])
        return (True, f"Verified via {matched_count} fields ({fields_str})")

    return (False, f"Need more verification - only {matched_count} field(s) matched")
