/**
 * Message Types for Claude Chat UI
 *
 * These types define the structure of messages displayed in the chat interface,
 * including user messages, assistant responses, and tool interactions.
 *
 * @module types/messages
 */

/**
 * Base interface for all message types.
 * Contains common properties shared across message variants.
 */
export interface BaseMessage {
  /** Unique identifier for the message */
  id: string;
  /** Timestamp when the message was created */
  timestamp: Date;
}

/**
 * Message sent by the user.
 */
export interface UserMessage extends BaseMessage {
  /** Discriminator for user messages */
  role: 'user';
  /** Text content of the user's message */
  content: string;
}

/**
 * Message generated by the assistant.
 * Supports streaming state for real-time response display.
 */
export interface AssistantMessage extends BaseMessage {
  /** Discriminator for assistant messages */
  role: 'assistant';
  /** Text content of the assistant's response */
  content: string;
  /** Whether the message is currently being streamed */
  isStreaming?: boolean;
}

/**
 * Message representing a tool invocation by the assistant.
 * Displayed when the assistant uses a tool to perform an action.
 */
export interface ToolUseMessage extends BaseMessage {
  /** Discriminator for tool use messages */
  role: 'tool_use';
  /** Name of the tool being invoked */
  toolName: string;
  /** Input parameters passed to the tool */
  input: Record<string, unknown>;
  /** Optional unique identifier for linking with tool results */
  toolUseId?: string;
}

/**
 * Message containing the result of a tool execution.
 * Displayed after a tool completes its operation.
 */
export interface ToolResultMessage extends BaseMessage {
  /** Discriminator for tool result messages */
  role: 'tool_result';
  /** Identifier linking this result to its corresponding tool_use message */
  toolUseId: string;
  /** Output content from the tool execution */
  content: string;
  /** Whether the tool execution resulted in an error */
  isError: boolean;
}

/**
 * System message for displaying status updates or notifications.
 * Used for connection status, errors, or other system-level information.
 */
export interface SystemMessage extends BaseMessage {
  /** Discriminator for system messages */
  role: 'system';
  /** Content of the system message */
  content: string;
  /** Severity level of the system message */
  level: 'info' | 'warning' | 'error';
}

/**
 * Union type representing all possible message types in the chat.
 * Use this type when handling messages that could be of any type.
 *
 * @example
 * ```typescript
 * function renderMessage(message: Message) {
 *   switch (message.role) {
 *     case 'user':
 *       return <UserBubble content={message.content} />;
 *     case 'assistant':
 *       return <AssistantBubble content={message.content} streaming={message.isStreaming} />;
 *     case 'tool_use':
 *       return <ToolUseIndicator name={message.toolName} input={message.input} />;
 *     case 'tool_result':
 *       return <ToolResultDisplay content={message.content} isError={message.isError} />;
 *     case 'system':
 *       return <SystemNotification content={message.content} level={message.level} />;
 *   }
 * }
 * ```
 */
export type Message =
  | UserMessage
  | AssistantMessage
  | ToolUseMessage
  | ToolResultMessage
  | SystemMessage;

/**
 * Current state of a conversation.
 * Tracks all messages, streaming status, and session information.
 */
export interface ConversationState {
  /** Unique session identifier for the conversation */
  sessionId: string | null;
  /** Array of all messages in the conversation */
  messages: Message[];
  /** Whether a response is currently being streamed */
  isStreaming: boolean;
  /** Whether the conversation is loading (e.g., resuming a session) */
  isLoading: boolean;
  /** Current error message, if any */
  error: string | null;
  /** Number of completed turns in the conversation */
  turnCount: number;
  /** Total API cost in USD for this conversation (optional) */
  totalCostUsd?: number;
}

/**
 * Initial state for a new conversation.
 * Use this when resetting or creating a new conversation.
 */
export const INITIAL_CONVERSATION_STATE: ConversationState = {
  sessionId: null,
  messages: [],
  isStreaming: false,
  isLoading: false,
  error: null,
  turnCount: 0,
};

/**
 * Type guard to check if a message is a UserMessage.
 *
 * @param message - The message to check
 * @returns True if the message is a UserMessage
 */
export function isUserMessage(message: Message): message is UserMessage {
  return message.role === 'user';
}

/**
 * Type guard to check if a message is an AssistantMessage.
 *
 * @param message - The message to check
 * @returns True if the message is an AssistantMessage
 */
export function isAssistantMessage(message: Message): message is AssistantMessage {
  return message.role === 'assistant';
}

/**
 * Type guard to check if a message is a ToolUseMessage.
 *
 * @param message - The message to check
 * @returns True if the message is a ToolUseMessage
 */
export function isToolUseMessage(message: Message): message is ToolUseMessage {
  return message.role === 'tool_use';
}

/**
 * Type guard to check if a message is a ToolResultMessage.
 *
 * @param message - The message to check
 * @returns True if the message is a ToolResultMessage
 */
export function isToolResultMessage(message: Message): message is ToolResultMessage {
  return message.role === 'tool_result';
}

/**
 * Type guard to check if a message is a SystemMessage.
 *
 * @param message - The message to check
 * @returns True if the message is a SystemMessage
 */
export function isSystemMessage(message: Message): message is SystemMessage {
  return message.role === 'system';
}

/**
 * Helper function to create a unique message ID.
 * Uses a combination of timestamp and random string.
 *
 * @returns A unique message identifier
 */
export function createMessageId(): string {
  return `msg_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;
}

/**
 * Factory function to create a new UserMessage.
 *
 * @param content - The text content of the user message
 * @returns A new UserMessage object
 */
export function createUserMessage(content: string): UserMessage {
  return {
    id: createMessageId(),
    role: 'user',
    content,
    timestamp: new Date(),
  };
}

/**
 * Factory function to create a new AssistantMessage.
 *
 * @param content - The text content of the assistant message
 * @param isStreaming - Whether the message is currently streaming
 * @returns A new AssistantMessage object
 */
export function createAssistantMessage(content: string = '', isStreaming: boolean = false): AssistantMessage {
  return {
    id: createMessageId(),
    role: 'assistant',
    content,
    isStreaming,
    timestamp: new Date(),
  };
}

/**
 * Factory function to create a new ToolUseMessage.
 *
 * @param toolName - Name of the tool being used
 * @param input - Input parameters for the tool
 * @param toolUseId - Optional unique identifier for the tool use
 * @returns A new ToolUseMessage object
 */
export function createToolUseMessage(
  toolName: string,
  input: Record<string, unknown>,
  toolUseId?: string
): ToolUseMessage {
  return {
    id: createMessageId(),
    role: 'tool_use',
    toolName,
    input,
    toolUseId,
    timestamp: new Date(),
  };
}

/**
 * Factory function to create a new ToolResultMessage.
 *
 * @param toolUseId - Identifier linking to the corresponding tool use
 * @param content - Result content from the tool
 * @param isError - Whether the result is an error
 * @returns A new ToolResultMessage object
 */
export function createToolResultMessage(
  toolUseId: string,
  content: string,
  isError: boolean = false
): ToolResultMessage {
  return {
    id: createMessageId(),
    role: 'tool_result',
    toolUseId,
    content,
    isError,
    timestamp: new Date(),
  };
}

/**
 * History message from the backend API.
 * Represents a stored message in the session history.
 */
export interface HistoryMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  tool_use?: Array<{
    id: string;
    name: string;
    input: Record<string, unknown>;
  }> | null;
  tool_results?: Array<{
    tool_use_id: string;
    content: string;
    is_error: boolean;
  }> | null;
  timestamp?: string | null;
}

/**
 * Response from the session history API endpoint.
 */
export interface SessionHistoryResponse {
  session_id: string;
  messages: HistoryMessage[];
  total_messages: number;
}

/**
 * Convert history messages from API to Message types for display.
 *
 * @param historyMessages - Array of history messages from the API
 * @returns Array of Message objects for the chat UI
 */
export function convertHistoryToMessages(historyMessages: HistoryMessage[]): Message[] {
  const messages: Message[] = [];

  for (const historyMsg of historyMessages) {
    const timestamp = historyMsg.timestamp ? new Date(historyMsg.timestamp) : new Date();

    if (historyMsg.role === 'user') {
      messages.push({
        id: historyMsg.id,
        role: 'user',
        content: historyMsg.content,
        timestamp,
      });
    } else if (historyMsg.role === 'assistant') {
      // Add assistant text message
      if (historyMsg.content) {
        messages.push({
          id: historyMsg.id,
          role: 'assistant',
          content: historyMsg.content,
          isStreaming: false,
          timestamp,
        });
      }

      // Add tool use messages
      if (historyMsg.tool_use && historyMsg.tool_use.length > 0) {
        for (const tool of historyMsg.tool_use) {
          messages.push({
            id: `${historyMsg.id}-tool-${tool.id}`,
            role: 'tool_use',
            toolName: tool.name,
            input: tool.input,
            toolUseId: tool.id,
            timestamp,
          });
        }
      }

      // Add tool result messages
      if (historyMsg.tool_results && historyMsg.tool_results.length > 0) {
        for (const result of historyMsg.tool_results) {
          messages.push({
            id: `${historyMsg.id}-result-${result.tool_use_id}`,
            role: 'tool_result',
            toolUseId: result.tool_use_id,
            content: result.content,
            isError: result.is_error,
            timestamp,
          });
        }
      }
    }
  }

  return messages;
}
