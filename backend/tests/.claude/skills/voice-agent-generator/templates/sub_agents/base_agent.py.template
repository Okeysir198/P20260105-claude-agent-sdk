"""
Base Agent Class for {agent_name}

Provides:
- Chat context preservation during handoffs
- Silent handoff mechanism with generate_reply(tool_choice="none")
- Shared userdata access

All configuration is handled in agents.py at the session level.
"""

import logging
from typing import Any, Optional

from livekit.agents.voice import Agent, RunContext

from shared_state import UserData

logger = logging.getLogger("{agent_id}")

# Type alias for RunContext with UserData
RunContext_T = RunContext[UserData]

# Constants used by BaseAgent
CHAT_CONTEXT_MAX_ITEMS = 6  # Max items from previous agent to include in handoff


class BaseAgent(Agent):
    """Base class for all agents with context preservation.

    Provides:
    - Chat context preservation during handoffs
    - Silent handoff mechanism
    - Shared userdata access
    - Helper methods for conversation management

    All configuration (LLM, STT, TTS, instructions, tools) is provided
    by the session level in agents.py via kwargs.

    Usage:
        Create specialized agents by inheriting from BaseAgent:

        class GreetingAgent(BaseAgent):
            async def on_enter(self) -> None:
                await super().on_enter()
                # Custom greeting logic here
    """

    def __init__(
        self,
        instructions: str,
        tools: list[Any],
        **kwargs
    ):
        """Initialize base agent.

        Args:
            instructions: Agent prompt/instructions
            tools: List of tool functions for this agent
            **kwargs: Additional Agent arguments (llm, stt, tts from session)
        """
        super().__init__(
            instructions=instructions,
            tools=tools,
            **kwargs,
        )

        # Centralized logging
        cls_name = self.__class__.__name__
        logger.info(f"Initializing {cls_name}")
        logger.debug(f"{cls_name} initialized with {len(tools)} tools")

    async def on_enter(self) -> None:
        """Called when this agent becomes active.

        Handles:
        - Loading previous agent's chat context
        - Adding current state as system message
        - Triggering initial reply generation

        Override in subclasses to add custom behavior:

            async def on_enter(self) -> None:
                await super().on_enter()
                # Custom logic here
        """
        cls_name = self.__class__.__name__
        logger.info(f"Entering agent: {cls_name}")

        userdata: UserData = self.session.userdata
        chat_ctx = self.chat_ctx.copy()

        # Add the previous agent's chat history to the current agent
        if isinstance(userdata.prev_agent, Agent):
            truncated_chat_ctx = userdata.prev_agent.chat_ctx.copy(
                exclude_instructions=True,  # Don't duplicate instructions
                exclude_function_call=False  # Keep tool call context
            ).truncate(max_items=CHAT_CONTEXT_MAX_ITEMS)
            existing_ids = {item.id for item in chat_ctx.items}
            items_copy = [
                item for item in truncated_chat_ctx.items if item.id not in existing_ids
            ]
            chat_ctx.items.extend(items_copy)

        # Add current user data as system message
        chat_ctx.add_message(
            role="system",
            content=f"You are {cls_name} agent. Current state:\n{userdata.summarize()}",
        )

        await self.update_chat_ctx(chat_ctx)

        # Silent handoff: generate reply without tool calls
        # This allows the new agent to introduce itself naturally
        await self.session.generate_reply(tool_choice="none")

    def get_userdata(self) -> UserData:
        """Get the current session's userdata.

        Returns:
            UserData instance with profile and session state
        """
        return self.session.userdata

    async def handoff_to(self, target_agent: Agent, reason: str = "") -> Agent:
        """Perform a silent handoff to another agent.

        The target agent will receive chat context and introduce itself.
        Use this in tool functions to transfer control.

        Args:
            target_agent: The agent to hand off to
            reason: Optional reason for the handoff (for logging)

        Returns:
            The target agent instance
        """
        logger.info(f"Handoff from {self.__class__.__name__} to {target_agent.__class__.__name__}: {reason}")
        userdata = self.get_userdata()
        userdata.prev_agent = self
        return target_agent


__all__ = [
    "BaseAgent",
    "RunContext_T",
    "CHAT_CONTEXT_MAX_ITEMS",
]
