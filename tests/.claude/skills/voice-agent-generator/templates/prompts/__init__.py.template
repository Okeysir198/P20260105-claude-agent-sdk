"""
Prompt versioning system with Mustache formatting.

Functions:
- load_prompt(agent_name, version=None) -> str
- format_prompt(template, **variables) -> str
- get_version_metadata() -> dict
"""

from pathlib import Path
from typing import Any

import yaml
import chevron


PROMPTS_DIR = Path(__file__).parent
VERSIONS_FILE = PROMPTS_DIR / "_versions.yaml"

# Cache for versions config
_versions_cache: dict | None = None


def load_prompt(prompt_name: str, version: str | None = None) -> str:
    """
    Load a prompt template by prompt name and version.

    Args:
        prompt_name: Prompt identifier (e.g., "prompt01_main")
        version: Version string (e.g., "v1", "v2"). If None, uses default.

    Returns:
        Raw template string from the prompt file.

    Examples:
        >>> load_prompt("prompt01_main")
        "You are {{ agent_name }}..."

        >>> load_prompt("prompt01_main", "v2")
        "Hi there, this is {{ agent_name }}..."
    """
    versions_data = _load_versions()

    # Determine version to use
    if version is None:
        version = versions_data.get("defaults", {}).get(prompt_name, "v1")

    # Build filename
    if version == "v1":
        filename = f"{prompt_name}.yaml"
    else:
        filename = f"{prompt_name}_{version}.yaml"

    file_path = PROMPTS_DIR / filename

    if not file_path.exists():
        raise FileNotFoundError(f"Prompt file not found: {file_path}")

    content = file_path.read_text(encoding="utf-8")
    data = yaml.safe_load(content)

    if isinstance(data, dict):
        return data.get("system") or data.get("prompt") or data.get("instructions") or ""

    return str(data) if data else ""


def format_prompt(template: str, **variables) -> str:
    """
    Format template using Mustache {{variable}} syntax.

    Args:
        template: Template string with {{placeholders}}
        **variables: Variable values to substitute

    Returns:
        Formatted string with placeholders replaced.

    Examples:
        >>> format_prompt("Hello {{name}}", name="Alex")
        "Hello Alex"

        >>> format_prompt("Balance: {{amount}}", amount=1000)
        "Balance: 1000"
    """
    if not template:
        return ""

    safe_vars = {k: _sanitize(v) for k, v in variables.items()}
    return chevron.render(template, safe_vars)


def get_version_metadata() -> dict:
    """
    Get metadata about all prompt versions.

    Returns:
        Dict containing versions info, defaults, and metrics.

    Example:
        >>> meta = get_version_metadata()
        >>> meta["versions"]["v1"]["description"]
        "Baseline professional prompts"
    """
    return _load_versions()


def _load_versions() -> dict:
    """Load and cache the versions configuration."""
    global _versions_cache

    if _versions_cache is not None:
        return _versions_cache

    if not VERSIONS_FILE.exists():
        _versions_cache = {"versions": {}, "defaults": {}, "metrics": {}}
        return _versions_cache

    content = VERSIONS_FILE.read_text(encoding="utf-8")
    _versions_cache = yaml.safe_load(content) or {}
    return _versions_cache


def _sanitize(value: Any, max_length: int = 500) -> str:
    """
    Sanitize value for safe prompt injection.

    - Converts to string
    - Removes null bytes
    - Normalizes whitespace
    - Truncates to max length
    """
    if value is None:
        return ""

    if isinstance(value, (int, float)):
        return str(value)

    text = str(value)
    text = text.replace("\x00", "")
    text = " ".join(text.split())

    if len(text) > max_length:
        text = text[:max_length] + "..."

    return text.strip()


def load_instruction(source: str, version: str | None = None) -> str:
    """
    Load instruction from a file path or agent name.

    This is a convenience wrapper that handles both:
    - File paths: "prompts/prompt01_main.yaml"
    - Agent names: "prompt01_main"

    Args:
        source: File path or agent name
        version: Optional version suffix

    Returns:
        Raw template string from the prompt file.
    """
    # Handle file path format (e.g., "prompts/prompt01_main.yaml")
    if source.endswith(".yaml") or source.endswith(".yml"):
        # Extract agent name from path
        filename = Path(source).stem  # "prompt01_main"
        return load_prompt(filename, version)

    # Handle direct agent name
    return load_prompt(source, version)


def format_instruction(template: str, **variables) -> str:
    """Alias for format_prompt for backward compatibility."""
    return format_prompt(template, **variables)


__all__ = [
    "load_prompt",
    "format_prompt",
    "get_version_metadata",
    # Aliases for backward compatibility
    "load_instruction",
    "format_instruction",
]
