"""
Shared state aggregator for {agent_name} sessions.

This module provides the UserData container that aggregates profile,
session state, and agent tracking into a single session state object.
"""

import logging
from dataclasses import dataclass, field
from datetime import datetime
from typing import TYPE_CHECKING, Any, Dict, Optional

from state import Profile, SessionState, CallOutcome

if TYPE_CHECKING:
    from livekit.agents import Agent

logger = logging.getLogger("{agent_id}")


@dataclass
class UserData:
    """
    Main session state container for voice agent calls.

    Aggregates profile, session state, and agent transition tracking.
    This is set as session.userdata and passed to all agents and tools.

    Access in tools via: context.userdata
    Access in agents via: self.session.userdata
    """

    profile: Profile
    session: SessionState = field(default_factory=SessionState)
    agents: Dict[str, "Agent"] = field(default_factory=dict)
    prev_agent: Optional["Agent"] = None

    # Metadata
    session_id: Optional[str] = None
    start_time: Optional[str] = None
    current_agent_id: Optional[str] = None
    job_context: Optional[Any] = None

    def summarize(self) -> str:
        """
        Generate a text summary of the session state for agent context.

        Returns:
            Formatted string containing profile info and session progress
        """
        lines = [
            f"Session: {self.session_id or 'N/A'}",
            "",
            "Profile:",
            f"  Name: {self.profile.name}",
            f"  User ID: {self.profile.user_id}",
        ]

        if self.profile.email:
            lines.append(f"  Email: {self.profile.email}")
        if self.profile.phone:
            lines.append(f"  Phone: {self.profile.phone}")

        progress = self.session.get_progress()
        lines.extend([
            "",
            "Session Progress:",
            f"  Current Agent: {progress['current_agent']}",
            f"  Workflow Step: {progress['workflow_step']}",
            f"  Verified: {'Yes' if progress['verified'] else 'No'}",
        ])

        if self.session.outcome:
            lines.append(f"\nOutcome: {self.session.outcome.value}")
            if self.session.outcome_reason:
                lines.append(f"  Reason: {self.session.outcome_reason}")

        if self.session.callback_scheduled:
            lines.append(f"\nCallback: {self.session.callback_datetime or 'TBD'}")
            if self.session.callback_reason:
                lines.append(f"  Reason: {self.session.callback_reason}")

        if self.session.notes:
            lines.extend(["", "Recent Notes:"])
            for note in self.session.notes[-5:]:
                lines.append(f"  {note}")

        return "\n".join(lines)

    def to_prompt_vars(self) -> dict:
        """Get variables for prompt template formatting."""
        return {
            "name": self.profile.name,
            "user_id": self.profile.user_id,
            "session_id": self.session_id or "",
            "is_verified": self.session.verified,
        }

    def cleanup(self) -> None:
        """
        Clean up session resources at end of call.

        Breaks circular references and clears large collections.
        Should be called in a finally block.
        """
        logger.info("Cleaning up UserData resources")

        if self.agents:
            logger.debug(f"Clearing {len(self.agents)} agent references")
            self.agents.clear()

        self.prev_agent = None

        if self.session.notes:
            logger.debug(f"Clearing {len(self.session.notes)} session notes")
            self.session.notes.clear()

        self.job_context = None
        logger.info("UserData cleanup complete")

    def set_outcome(self, outcome: CallOutcome, reason: Optional[str] = None) -> None:
        """Set the call outcome with optional reason."""
        self.session.set_outcome(outcome, reason)

    def get_duration_seconds(self) -> Optional[int]:
        """Get session duration in seconds if start time is set."""
        if not self.start_time:
            return None
        try:
            start = datetime.fromisoformat(self.start_time)
            return int((datetime.now() - start).total_seconds())
        except ValueError:
            return None


def get_test_profile() -> Dict[str, Any]:
    """
    Default test profile data for local development.

    Returns:
        Dictionary with 'profile' key containing test data
    """
    return {
        "profile": {
            "name": "Test User",
            "user_id": "TEST001",
            "email": "test@example.com",
            "phone": "0821234567",
        },
    }


def create_test_userdata() -> UserData:
    """
    Create test UserData instance for eval framework.

    Returns:
        Fully populated UserData instance for testing
    """
    data = get_test_profile()
    profile = Profile.from_metadata(data["profile"])
    session = SessionState()
    return UserData(
        profile=profile,
        session=session,
        session_id=datetime.now().strftime("%Y%m%d_%H%M%S"),
    )
